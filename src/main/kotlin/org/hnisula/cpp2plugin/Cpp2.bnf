{
    parserClass="org.hnisula.cpp2plugin.parser.Cpp2Parser"
    
    extends="com.intellij.extapi.psi.ASTWrapperPsiElement"
    
    psiClassPrefix="Cpp2"
    psiImplClassSuffix="Impl"
    psiPackage="org.hnisula.cpp2plugin.psi"
    psiImplPackage="org.hnisula.cpp2plugin.psi.impl"
    
    elementTypeHolderClass="org.hnisula.cpp2plugin.psi.Cpp2Types"
    elementTypeClass="org.hnisula.cpp2plugin.psi.Cpp2ElementType"
    tokenTypeClass="org.hnisula.cpp2plugin.psi.Cpp2TokenType"
    
    psiImplUtilClass="org.hnisula.cpp2plugin.psi.Cpp2PsiUtil"
    methods=[getContext]
    
    extends(".*expr")=expr
    
    tokens=[
        ARROW               = '->'
        COLONCOLON          = '::'
        DOTDOTDOT           = '...'
        PLUSPLUS            = '++'
        MINUSMINUS          = '--'
        OROR                = '||'
        ANDAND              = '&&'
        EQEQ                = '=='
        NEQ                 = '!='
        LTEQ                = '<='
        GTEQ                = '>='
        LTLT                = '<<'
        GTGT                = '>>'
        
        NEWLINE             = '\n'
        
        COLON               = ':'
        SEMICOLON           = ';'
        LEFT_BRACE          = '{'
        RIGHT_BRACE         = '}'
        LEFT_PARENTHESIS    = '('
        RIGHT_PARENTHESIS   = ')'
        LT                  = '<'
        GT                  = '>'
        EQ                  = '='
        UNDERSCORE          = '_'
        PLUS                = '+'
        MINUS               = '-'
        SLASH               = '/'
        MODULO              = '%'
        AND                 = '&'
        OR                  = '|'
        EXP                 = '^'
        DOT                 = '.'
        COMMA               = ','
        
        TYPE_WORD           = 'type'
        THIS                = 'this'
        PUBLIC              = 'public'
        PROTECTED           = 'protected'
        PRIVATE             = 'private'
        NAMESPACE           = 'namespace'
        USING               = 'using'
        
        FOR                 = 'for'
        WHILE               = 'while'
        DO                  = 'do'
        NEXT                = 'next'
        IF                  = 'if'
        ELSE                = 'else'
        CONST               = 'const'
        RETURN              = 'return'
        
        IN                  = 'in'
        COPY                = 'copy'
        INOUT               = 'inout'
        OUT                 = 'out'
        MOVE                = 'move'
        FORWARD             = 'forward'
        
        VIRTUAL             = 'virtual'
        OVERRIDE            = 'override'
        FINAL               = 'final'
        
    ]
}

// Root stuff

file ::= file_wrapper
file_wrapper ::= root_stmts {
    implements=["org.hnisula.cpp2plugin.Cpp2Scope"]
    mixin="org.hnisula.cpp2plugin.psi.Cpp2FileWrapperMixin"
}

root_stmt_block     ::= '{' root_stmt* '}'
root_stmts          ::= root_stmt*
private root_stmt   ::= (type_decl | func_decl | namespace_decl | value_decl_stmt | comment)

stmt_block          ::= '{' stmt* '}'
private stmt        ::= (func_decl | value_decl_stmt | alias_decl | assign | using_namespace | expr_stmt | if_branch | for_loop | do_while_loop | while_loop | comment)
private expr_stmt   ::= expr ';'

// Loops and branching

for_loop        ::= 'for' expr next_stmt? 'do' param_list stmt_block {
    pin='for'
}
do_while_loop   ::= 'do' stmt_block next_stmt? 'while' expr ';' {
    pin='do'
}
while_loop      ::= 'while' expr next_stmt? stmt_block {
    pin='while'
}
next_stmt       ::= 'next' expr {
    pin='next'
}

if_branch ::= 'if' expr stmt_block ('else' 'if' expr stmt_block)* ('else' stmt_block)?

// Aliases

private alias_decl      ::= obj_alias_decl | func_alias_decl | type_alias_decl | namespace_alias_decl
namespace_alias_decl    ::= IDENTIFIER_WORD ':' 'namespace' '==' namespace_ref ';' {
    pin='=='
}
type_alias_decl         ::= IDENTIFIER_WORD ':' 'type' '==' type_specifier ';' {
    pin='=='
}
func_alias_decl         ::= IDENTIFIER_WORD ':' template_decl? param_list return_type? (('==' stmt_block) | ('=='? expr ';')) {
    pin=param_list
}
obj_alias_decl          ::= IDENTIFIER_WORD ':' type_specifier? '==' expr ';' {
    pin='=='
}

// Declaration and assignment

assign                  ::= expr '=' expr ';'
private value_decl_stmt ::= value_decl ';'
value_decl              ::= IDENTIFIER_WORD ':' ((type_specifier '=' expr) | type_specifier | ('=' expr)) {
    pin=3
}

// Namespace

using_namespace ::= 'using' 'namespace'? q_identifier ';' {
    pin='using'
}
namespace_decl  ::= identifier ':' 'namespace' '=' root_stmt_block {
    pin=3
}

// Functions

func_decl       ::= IDENTIFIER_WORD ':' template_decl? param_list return_type? (('=' stmt_block) | ('='? expr ';')) {
    pin=param_list
}
return_type     ::= '->' ('_' | type_specifier)

func_call           ::= q_identifier '(' arg* ')' {extends=expr}
arg                 ::= param_kind? expr
param_list          ::= '(' ((this_param | param) (',' param)*)? ')'
param               ::= param_kind? (value_decl | variadic_param)
this_param          ::= this_param_kind? 'this'
variadic_param      ::= IDENTIFIER_WORD '...'

// Type declaration

type_decl           ::= IDENTIFIER_WORD ':' template_decl? METAFUNCTION? 'type' '=' '{' member_decl* '}' {
    pin='type'
    implements=["org.hnisula.cpp2plugin.Cpp2NamedDeclaration"]
    mixin="org.hnisula.cpp2plugin.psi.Cpp2TypeDeclMixin"
}
member_decl         ::= (member_access? (type_decl | func_decl | (value_decl ';') | comment))
member_access       ::= ('public' | 'protected' | 'private')

// Expressions and operators

expr ::= group_14_expr | group_13_expr | group_12_expr | group_11_expr | group_10_expr | group_9_expr | group_8_expr | group_7_expr | group_6_expr | group_5_expr | group_2_expr | q_identifier | literal | paren_expr | list_expr

paren_expr              ::= '(' expr? ')'
list_expr               ::= '(' (expr (',' expr)* ','?)? ')'
private group_14_expr   ::= or_expr
private group_13_expr   ::= and_expr
private group_12_expr   ::= bit_or_expr
private group_11_expr   ::= bit_xor_expr
private group_10_expr   ::= bit_and_expr
private group_9_expr    ::= eq_expr | neq_expr
private group_8_expr    ::= lt_expr | gt_expr | lteq_expr | gteq_expr
private group_7_expr    ::= left_shift_expr | right_shift_expr
private group_6_expr    ::= add_expr | sub_expr
private group_5_expr    ::= mul_expr | div_expr | mod_expr
private group_2_expr    ::= func_call | subscript_expr

or_expr             ::= expr '||'   expr    {rightAssociative=false}
and_expr            ::= expr '&&'   expr    {rightAssociative=false}
bit_or_expr         ::= expr '|'    expr    {rightAssociative=false}
bit_xor_expr        ::= expr '^'    expr    {rightAssociative=false}
bit_and_expr        ::= expr '&'    expr    {rightAssociative=false}
eq_expr             ::= expr '=='   expr    {rightAssociative=false}
neq_expr            ::= expr '!='   expr    {rightAssociative=false}
lteq_expr           ::= expr '<='   expr    {rightAssociative=false}
gteq_expr           ::= expr '>='   expr    {rightAssociative=false}
lt_expr             ::= expr '<'    expr    {rightAssociative=false}
gt_expr             ::= expr '>'    expr    {rightAssociative=false}
right_shift_expr    ::= expr '>>'   expr    {rightAssociative=false}
left_shift_expr     ::= expr '<<'   expr    {rightAssociative=false}
add_expr            ::= expr '+'    expr    {rightAssociative=false}
sub_expr            ::= expr '-'    expr    {rightAssociative=false}
mul_expr            ::= expr MUL    expr    {rightAssociative=false}
div_expr            ::= expr '/'    expr    {rightAssociative=false}
mod_expr            ::= expr '%'    expr    {rightAssociative=false}
subscript_expr      ::= expr '[' expr ']'   {rightAssociative=false}

deref_expr          ::= expr DEREF

// Misc fundamentals

template_decl               ::= '<' template_decl_item (',' template_decl_item)* ','? '>'
private template_decl_item  ::= (IDENTIFIER_WORD (':' (TYPE_WORD | type_specifier))?) | (IDENTIFIER_WORD '...' (':' TYPE_WORD)?)
template                    ::= '<' (type_specifier (',' type_specifier)* ','?)? '>'
type_specifier              ::= qualifier* q_identifier template?
q_identifier                ::= '::'? (identifier template? '::')* identifier template? {
    extends=expr
}

identifier                  ::= IDENTIFIER_WORD {
    implements="org.hnisula.cpp2plugin.Cpp2Reference"
    mixin="org.hnisula.cpp2plugin.psi.Cpp2IdentifierMixin"
}
literal                     ::= BOOL_LITERAL | INT_LITERAL | FLOAT_LITERAL | STRING_LITERAL {extends=expr}

private qualifier           ::= ('const' | '*')
private this_param_kind     ::= ('virtual' | 'override' | 'final' | param_kind)
private param_kind          ::= ('in' | 'copy' | 'inout' | 'out' | 'move' | 'forward')